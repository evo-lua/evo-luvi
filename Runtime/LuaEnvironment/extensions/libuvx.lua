local uv = require("uv")

uv.errors = {
	E2BIG = "Argument list too long",
	EACCES = "Permission denied",
	EADDRINUSE = "Address already in use",
	EADDRNOTAVAIL = "Address not available",
	EAFNOSUPPORT = "Address family not supported",
	EAGAIN = "Resource temporarily unavailable",
	EAI_ADDRFAMILY = "Address family not supported",
	EAI_AGAIN = "Temporary failure",
	EAI_BADFLAGS = "Bad ai_flags value",
	EAI_BADHINTS = "Invalid value for hints",
	EAI_CANCELED = "Request cancelled",
	EAI_FAIL = "Permanent failure",
	EAI_FAMILY = "ai_family not supported",
	EAI_MEMORY = "Out of memory",
	EAI_NODATA = "No address",
	EAI_NONAME = "Unknown node or service",
	EAI_OVERFLOW = "Argument buffer overflow",
	EAI_PROTOCOL = "Resolved protocol is unknown",
	EAI_SERVICE = "Service not available for socket type",
	EAI_SOCKTYPE = "Socket type not supported",
	EALREADY = "Connection already in progress",
	EBADF = "Bad file descriptor",
	EBUSY = "Resource busy or locked",
	ECANCELED = "Operation canceled",
	ECHARSET = "Invalid Unicode character",
	ECONNABORTED = "Software caused connection abort",
	ECONNREFUSED = "Connection refused",
	ECONNRESET = "Connection reset by peer",
	EDESTADDRREQ = "Destination address required",
	EEXIST = "File already exists",
	EFAULT = "Bad address in system call argument",
	EFBIG = "File too large",
	EHOSTUNREACH = "Host is unreachable",
	EINTR = "Interrupted system call",
	EINVAL = "Invalid argument",
	EIO = "I/O error",
	EISCONN = "Socket is already connected",
	EISDIR = "Illegal operation on a directory",
	ELOOP = "Too many symbolic links encountered",
	EMFILE = "Too many open files",
	EMSGSIZE = "Message too long",
	ENAMETOOLONG = "Name too long",
	ENETDOWN = "Network is down",
	ENETUNREACH = "Network is unreachable",
	ENFILE = "File table overflow",
	ENOBUFS = "No buffer space available",
	ENODEV = "No such device",
	ENOENT = "No such file or directory",
	ENOMEM = "Not enough memory",
	ENONET = "Machine is not on the network",
	ENOPROTOOPT = "Protocol not available",
	ENOSPC = "No space left on device",
	ENOSYS = "Function not implemented",
	ENOTCONN = "Socket is not connected",
	ENOTDIR = "Not a directory",
	ENOTEMPTY = "Directory not empty",
	ENOTSOCK = "Socket operation on non-socket",
	ENOTSUP = "Operation not supported on socket",
	EOVERFLOW = "Value too large for defined data type",
	EPERM = "Operation not permitted",
	EPIPE = "Broken pipe",
	EPROTO = "Protocol error",
	EPROTONOSUPPORT = "Protocol not supported",
	EPROTOTYPE = "Protocol wrong type for socket",
	ERANGE = "Result too large",
	EROFS = "Read-only file system",
	ESHUTDOWN = "Cannot send after transport endpoint shutdown",
	ESPIPE = "Invalid seek",
	ESRCH = "No such process",
	ETIMEDOUT = "Connection timed out",
	ETXTBSY = "Text file is busy",
	EXDEV = "Cross-device link not permitted",
	UNKNOWN = "Unknown error",
	EOF = "End of file",
	ENXIO = "No such device or address",
	EMLINK = "Too many links",
	ENOTTY = "Inappropriate ioctl for device",
	EFTYPE = "Inappropriate file type or format",
	EILSEQ = "Illegal byte sequence",
	ESOCKTNOSUPPORT = "Socket type not supported",
}

-- It might be better to expose the libuv API directly for this, but since it can leak memory that's somewhat questionable
function uv.strerror(libuvErrorCode)
	return uv.errors[libuvErrorCode] or uv.errors.UNKNOWN
end

return uv
